// Methods

// Методы — это функции, связанные с определенным типом. Classes, structures, and enumerations могут определять instance methods, которые инкапсулируют определенные задачи и функции для работы с экземпляром данного типа. Classes, structures, and enumerations также могут определять type methods, связанные с самим типом.
// В Swift вы можете выбрать, следует ли определять class, structure, or enumeration, и при этом иметь возможность определять методы для создаваемого вами типа.


// 1. Instance Methods (Методы экземпляра)

// Instance Methods — это функции, принадлежащие экземплярам определенного class, structure, or enumeration. Они поддерживают функциональность этих экземпляров, либо предоставляя способы доступа и изменения свойств экземпляра, либо предоставляя функциональные возможности, связанные с назначением экземпляра. Instance Methods имеют точно такой же синтаксис, что и функции.
// Вы пишете метод экземпляра внутри открывающей и закрывающей фигурных скобок типа, к которому он принадлежит. Instance Methods имеет неявный доступ ко всем другим методам и свойствам экземпляра этого типа. Instance Methods можно вызывать только для конкретного экземпляра того типа, к которому он принадлежит. Его нельзя вызвать изолированно без существующего экземпляра.
// Вот пример, определяющий простой class Counter, который можно использовать для подсчета количества повторений действия:
/*
class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}

// class Counter определяет три метода экземпляра:

// increment() увеличивает счетчик на 1.
// increment(by: Int) увеличивает счетчик на заданную целочисленную величину.
// reset() сбрасывает счетчик на ноль.
// class Counter также объявляет переменное свойство count для отслеживания текущего значения счетчика.

// Instance Methods вызываются с тем же точечным синтаксисом, что и properties:
let counter = Counter()
// начальное значение счетчика равно 0
counter.increment()
// значение счетчика теперь равно 1
counter.increment(by: 5)
// значение счетчика теперь равно 6
counter.reset()
// значение счетчика теперь равно 0

// Параметры функции могут иметь как имя (для использования в теле функции), так и метку аргумента (для использования при вызове функции), и имена параметров. То же самое верно и для параметров метода, потому что методы — это просто функции, связанные с типом.
*/

// 2. The self Property

// Каждый экземпляр типа имеет неявное свойство self, которое точно эквивалентно самому экземпляру. Вы используете свойство self для ссылки на текущий экземпляр в его собственных методах экземпляра.
// Метод increment() в приведенном выше примере можно было бы написать так:

class Counter {
    var count = 0
    func increment() {
        self.count += 1
    }
}

// На практике вам не нужно часто писать self в коде. Если вы явно не пишете self, Swift предполагает, что вы ссылаетесь на свойство или метод текущего экземпляра всякий раз, когда вы используете известное имя свойства или метода внутри метода. Это предположение демонстрируется использованием count (а не self.count) внутри трех методов экземпляра для Counter.
// Основное исключение из этого правила возникает, когда имя параметра для instance method совпадает с именем свойства этого экземпляра. В этой ситуации имя параметра имеет приоритет, и возникает необходимость обращаться к свойству более квалифицированным образом. Вы используете свойство self, чтобы различать имя параметра и имя свойства, например:
/*
struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOf(x: Double) -> Bool {
        return self.x > x
    }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOf(x: 1.0) {
    print("This point is to the right of the line where x == 1.0")
}
*/

// Prints "This point is to the right of the line where x == 1.0"


// 3. Modifying Value Types from Within Instance Methods (Изменение Value Types из Instance Methods)

// Structures и enumerations являются value types. По умолчанию свойства value type не могут быть изменены из instance methods.
// Однако, если вам нужно изменить свойства вашей structure или enumeration в определенном методе, вы можете выбрать изменение поведения для этого метода. Затем метод может видоизменять (то есть изменять) свои свойства внутри метода, и любые изменения, которые он делает, записываются обратно в исходную структуру, когда метод завершается. Метод также может назначить совершенно новый экземпляр своему неявному свойству self, и этот новый экземпляр заменит существующий, когда метод завершится.
// Вы можете включить это поведение, поместив ключевое слово mutating перед ключевым словом func для этого метода:
/*
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}

var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// Prints "The point is now at (3.0, 4.0)"

// Приведенная выше структура Point определяет mutating moveBy(x:y:) метод, который перемещает экземпляр Point на определенную величину. Вместо того, чтобы возвращать новую точку, этот метод фактически изменяет точку, для которой он вызывается. Ключевое слово mutating добавляется к его определению, чтобы позволить ему изменять свои свойства.

let fixedPoint = Point(x: 3.0, y: 3.0)
// fixedPoint.moveBy(x: 2.0, y: 3.0)
// this will report an error
// !!! недьзя вызвать mutating method для константы структурного типа, потому что ее свойства не могут быть изменены, даже если они являются переменными свойствами.
*/


// 4. Assigning to self Within a Mutating Method (Присвоение self в Mutating Method)

// Mutating Method могут назначать совершенно новый экземпляр неявному свойству self. Показанный выше пример Point мог бы быть записан следующим образом:

struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}

// Эта версия mutating moveBy(x:y:) method создает новую структуру, значения x и y которой устанавливаются в целевом местоположении. Конечный результат вызова этой альтернативной версии метода будет точно таким же, как и при вызове более ранней версии.

// Mutating methods для enumerations могут установить для неявного параметра self значение, отличное от того же перечисления:

enum TriStateSwitch {
    case off, low, high
    mutating func next() {
        switch self {
        case .off:  self = .low
        case .low:  self = .high
        case .high: self = .off
        }
    }
}
var ovenLight = TriStateSwitch.low
ovenLight.next()
// ovenLight теперь равна .high
ovenLight.next()
// ovenLight теперь равна to .off

// В этом примере определяется enumeration для переключателя с тремя состояниями. Переключатель переключается между тремя различными состояниями питания (off, low and high) каждый раз, когда вызывается его метод next().


// 5. Type Methods

//Instance methods, как описано выше, — это методы, которые вы вызываете для экземпляра определенного типа. Вы также можете определить методы, которые вызываются для самого типа. Такие методы называются type methods. Вы указываете методы типа, написав ключевое слово static перед ключевым словом func метода. Вместо этого классы могут использовать ключевое слово class, чтобы позволить подклассам переопределять реализацию этого метода в суперклассе.
// ПРИМЕЧАНИЕ!!! В Swift вы можете определить методы уровня типа для всех classes, structures, and enumerations. Каждый метод типа явно привязан к типу, который он поддерживает.
// Type Methods вызываются с точечным синтаксисом, как и instance methods. Однако вы вызываете type methods для типа, а не для экземпляра этого типа. Вот как вы вызываете type methods в class SomeClass:

class SomeClass {
    class func someTypeMethod() {
        // здесь идет реализация type method
    }
}
SomeClass.someTypeMethod()

// В теле type method неявное свойство self относится к самому типу, а не к экземпляру этого типа. Это означает, что вы можете использовать self для устранения неоднозначности между type properties и параметрами type method, точно так же, как вы делаете это для instance properties и параметров instance method.
// В более общем смысле любые неквалифицированные имена методов и свойств, которые вы используете в теле метода типа, будут ссылаться на другие методы и свойства уровня типа. Type method может вызывать другой type method с именем другого метода без необходимости префикса с именем типа. Точно так же type methods в structures и enumerations могут обращаться к type properties, используя имя type property’s без префикса имени типа.

// В приведенном ниже примере определяется структура под названием LevelTracker, которая отслеживает продвижение игрока по различным уровням или этапам игры. Это однопользовательская игра, но она может хранить информацию для нескольких игроков на одном устройстве.
// Все уровни игры (кроме первого) заблокированы при первом запуске игры. Каждый раз, когда игрок завершает уровень, этот уровень разблокируется для всех игроков на устройстве. Структура LevelTracker использует type properties и methods, чтобы отслеживать, какие уровни игры были разблокированы. Он также отслеживает текущий уровень для отдельного игрока.

struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1

    static func unlock(_ level: Int) {
        if level > highestUnlockedLevel { highestUnlockedLevel = level }
    }

    static func isUnlocked(_ level: Int) -> Bool {
        return level <= highestUnlockedLevel
    }

    @discardableResult
    mutating func advance(to level: Int) -> Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}

// Структура LevelTracker отслеживает самый высокий уровень, разблокированный любым игроком. Это значение хранится в type property с именем highestUnlockedLevel.
// LevelTracker также определяет две функции типа для работы со свойством highUnlockedLevel. Первая — это функция типа, называемая unlock(_:), которая обновляет значение highUnlockedLevel всякий раз, когда открывается новый уровень. Вторая — это функция удобного типа, называемая isUnlocked(_:), которая возвращает true, если определенный номер уровня уже разблокирован. (Обратите внимание, что эти методы типа могут получить доступ к свойству типа highUnlockedLevel без необходимости записывать его как LevelTracker.highestUnlockedLevel.)
// В дополнение к type property и type methods LevelTracker отслеживает прогресс отдельного игрока в игре. Он использует instance property под названием currentLevel для отслеживания уровня, на котором в данный момент играет игрок.
// Чтобы упростить управление свойством currentLevel, LevelTracker определяет instance method с именем advance(to:). Перед обновлением currentLevel этот метод проверяет, не разблокирован ли запрошенный новый уровень. Метод advance(to:) возвращает логическое значение, указывающее, действительно ли он смог установить currentLevel. Поскольку код, вызывающий метод advance(to:), игнорирует возвращаемое значение, не обязательно является ошибкой, эта функция помечается атрибутом @discardableResult.

// Структура LevelTracker используется с показанным ниже классом Player для отслеживания и обновления прогресса отдельного игрока:

class Player {
    var tracker = LevelTracker()
    let playerName: String
    func complete(level: Int) {
        LevelTracker.unlock(level + 1)
        tracker.advance(to: level + 1)
    }
    init(name: String) {
        playerName = name
    }
}

// Класс Player создает новый экземпляр LevelTracker для отслеживания прогресса этого игрока. Он также предоставляет метод complete(level:), который вызывается всякий раз, когда игрок завершает определенный уровень. Этот метод открывает следующий уровень для всех игроков и обновляет прогресс игрока, чтобы перейти на следующий уровень. (Возвращаемое логическое значение advance(to:) игнорируется, поскольку известно, что уровень был разблокирован вызовом LevelTracker.unlock(_:) в предыдущей строке.)

// Вы можете создать экземпляр класса Player для нового игрока и посмотреть, что произойдет, когда игрок завершит первый уровень:

var player = Player(name: "Argyrios")
player.complete(level: 1)
print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
// Prints "highest unlocked level is now 2"

// Если вы создаете второго игрока, которого вы пытаетесь переместить на уровень, который еще не разблокирован ни одним игроком в игре, попытка установить текущий уровень игрока не удалась:

player = Player(name: "Beto")
if player.tracker.advance(to: 6) {
    print("player is now on level 6")
} else {
    print("level 6 hasn't yet been unlocked")
}
// Prints "level 6 hasn't yet been unlocked"
